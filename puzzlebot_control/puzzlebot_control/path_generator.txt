"""
Node that generates different paths acoording to a user.
The path must be defined in the parameter files by the user. The paths are found in /config/params.yaml
The path must be defined by different points, velocities of the robot, or a time (dependent on the user)
    For each point, the node must estimate the linear and rotational speeds in case a time is given or estimate a time
    in case the velocities are provided
The node must let the user know if the point is reachable.
Take into consideration robustness.
The message for the topic /pose must be a custom message based on the pose geometry_msgs type with an added
field for velocities or time.
"""

"""
The code does the following:
    1.- Creates a PathGeneratorNode() object which:
        - Publishes PathPoint messages to the pose topic.
        - Loads path definitions from ROS2 parameters.
        - Allows selection of the current path using the current_path parameter.
    2.- Implements parameter parsing with two different approaches:
        - Direct parameter access from ROS2 parameter server.
        - YAML parsing as a fallback method.
        - Hardcoded defaults if both methods fail.
    3.- Includes a publisher that:
        - Publishes each path point in sequence.
        - Includes position, orientation, velocity, and time information.
        - Terminates when the path is completed.
    The code can handle the path formats seen in /config/params.yaml.
"""

# Imports
import rclpy
from rclpy.node import Node
import numpy as np
from std_msgs.msg import Float32
from geometry_msgs.msg import Pose, Twist
from rcl_interfaces.msg import ParameterDescriptor
from challenge_interfaces.msg import PathPoint
import yaml
import math

#Class definition
class PathGeneratorNode(Node):
    def __init__(self):
        super().__init__('path_generator_node')

        # Publisher to /pose
        self.path_point_pub = self.create_publisher(PathPoint, 'pose', 10)

        # Declare parameter for selecting path
        self.declare_parameter('current_path', 'square_path_time', 
                               ParameterDescriptor(description='The path to publish'))
        
        # Load paths from parameters
        self.paths = self.get_paths_from_params()

        # Get the current selected path
        self.current_path_name = self.get_parameter('current_path').get_parameter_value().string_value
        self.get_logger().info(f"Selected path: {self.current_path_name}")

        # Set initial values
        self.current_path = self.paths.get(self.current_path_name, [])
        self.current_point_index = 0
        self.total_points = len(self.current_path) if self.current_path else 0

        if self.total_points == 0:
            self.get_logger().error(f"Path '{self.current_path_name}' not found or empty!")
            return

        # Timer to update state machine
        self.timer_period = 0.2 # 10 Hz control loop
        self.timer = self.create_timer(self.timer_period, self.publish_path_point())

        self.get_logger().info(f"Path generator initialized with '{self.total_points}' points for path: '{self.current_path_name}'.")

    def get_paths_from_params(self):
        """ Load path definitions from ROS2 parameters """
        paths = {}

        # Get all parameters stored in paths
        path_params = self.declare_parameter('paths', {}).get_parameter_value().string_array_value

        # Check if parameters were loaded
        if not path_params:
            self.get_logger().warn("No path parameters found. Using default paths.")
            return paths
        
        # Try to get paths from each parameter namespace
        path_names = ['square_path_time', 'square_path_speed',
                      'figure_8_path_time', 'figure_8_path_speed',
                      'triangle_path_time', 'triangle_path_speed'
                      ]
        
        for path_name in path_names:
            param_prefix = f'paths.{path_name}'
            path_points = []

            # Check if this path exists in parameters
            try:
                # Get the number of points in this path
                point_count_param = self.get_parameter(f'{param_prefix}.point_count')
                point_count = point_count_param.get_parameter_value().integer_value
            except:
                # Try another approach - check if the first point exists
                try:
                    test_param = self.get_parameter(f'{param_prefix}.0.point.pose.position.x')
                    # If we get here, the parameter exists so let's count points
                    point_count = 0
                    while True:
                        try:
                            test_param = self.get_parameter(f'{param_prefix}.{point_count}.point.pose.position.x')
                            point_count += 1
                        except:
                            break
                except:
                    self.get_logger().debug(f"Path {path_name} not found in parameters.")
                    continue
            
            self.get_logger().info(f"Found '{point_count}' points for path: '{path_name}'.")

            # Parse each point in the path
            for i in range(point_count):
                try:
                    # Create PathPoint message
                    path_point = PathPoint()

                    # Get pose
                    path_point.pose.position.x = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.position.x', 0.0).value
                    path_point.pose.position.y = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.position.y', 0.0).value
                    path_point.pose.position.z = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.position.z', 0.0).value
                    
                    # Get orientation
                    path_point.pose.orientation.x = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.orientation.x', 0.0).value
                    path_point.pose.orientation.y = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.orientation.y', 0.0).value
                    path_point.pose.orientation.z = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.orientation.z', 0.0).value
                    path_point.pose.orientation.w = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.pose.orientation.w', 0.0).value
                    
                    # Get linear velocity
                    path_point.velocity.linear.x = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.velocity.linear.x', 0.0).value
                    path_point.velocity.linear.y = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.velocity.linear.y', 0.0).value
                    path_point.velocity.linear.z = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.velocity.linear.z', 0.0).value
                    
                    # Get angular velocity
                    path_point.velocity.angular.x = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.velocity.angular.x', 0.0).value
                    path_point.velocity.angular.y = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.velocity.angular.y', 0.0).value
                    path_point.velocity.angular.z = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.velocity.angular.z', 0.0).value
                    
                    # Get time
                    path_point.time = self.get_parameter_or(
                        f'{param_prefix}.{i}.point.time', 0.0).value
                    
                    path_points.append(path_point)
                    self.get_logger().debug(f"Added point '{i}' to path '{path_name}'.")
                
                except Exception as e:
                    self.get_logger().error(f"Error parsing point '{i}' of path '{path_name}': {str(e)}.")
                    continue

            if path_points:
                paths[path_name] = path_points
                self.get_logger().info(f"Successfully loaded path: '{path_name}' with '{len(path_points)}' points.")
        
        # Alternative parsing for paths directly from YAML structure
        if not paths:
            self.get_logger("Trying alternative path parsing method. Reading directly from YAML structure from /config/params.yaml")
            try:
                # Declare paths parameters explicitly with recursive declarations
                self.declare_parameters(
                    namespace='',
                    parameters=[
                        ('paths.square_path_time', None),
                        ('paths.square_path_speed', None),
                        ('paths.figure_8_path_time', None),
                        ('paths.figure_8_path_speed', None)
                        ('paths.triangle_path_time', None),
                        ('paths.triangle_path_speed', None),
                    ]
                )
            
                # Parse each path
                for path_name in path_names:
                    try:
                        path_param = self.get_parameter(f'paths.{path_name}') # point
                        path_data = path_param.get_parameter_value().string_value # pose, velocity and time

                        # If it is a string, try to parse as YAML
                        if path_data:
                            try:
                                path_list = yaml.safe_load(path_data)
                                path_points = []

                                for point_data in path_list:
                                    path_point = PathPoint()

                                    # Set pose
                                    pose_data = point_data.get('point', {}).get('pose', {})
                                    position = pose_data.get('position', {})
                                    orientation = pose_data.get('orientation', {})

                                    path_point.pose.position.x = float(position.get('x', 0.0))
                                    path_point.pose.position.y = float(position.get('y', 0.0))
                                    path_point.pose.position.z = float(position.get('z', 0.0))

                                    path_point.pose.orientation.x = float(orientation.get('x', 0.0))
                                    path_point.pose.orientation.y = float(orientation.get('y', 0.0))
                                    path_point.pose.orientation.z = float(orientation.get('z', 0.0))
                                    path_point.pose.orientation.w = float(orientation.get('w', 0.0))

                                    # Set velocity
                                    velocity_data = point_data.get('point', {}).get('velocity', {})
                                    linear = velocity_data.get('linear', {})
                                    angular = velocity_data.get('angular', {})

                                    path_point.velocity.linear.x = float(linear.get('x', 0.0))
                                    path_point.velocity.linear.y = float(linear.get('x', 0.0))
                                    path_point.velocity.linear.z = float(linear.get('x', 0.0))

                                    path_point.velocity.angular.x = float(angular.get('x', 0.0))
                                    path_point.velocity.angular.y = float(angular.get('y', 0.0))
                                    path_point.velocity.angular.z = float(angular.get('z', 0.0))

                                    # Set time
                                    path_point.time = point_data.get('point', {}).get('time', {})

                                    path_points.append(path_point)
                                
                                paths[path_name] = path_points
                                self.get_logger().info(f"Loaded path '{path_name}' with '{len(path_points)}' points.")
                            except Exception as e:
                                self.get_logger().error(f"Failed to parse YAML for path {path_name}: {str(e)}.")

                    except:
                        pass
            except Exception as e:
                self.get_logger().error(f"Alternative path parsing failed: {str(e)}.")

            # Create hardcoded default paths if none were loaded
            if not paths:
                self.get_logger().warn("Using hardcoded default paths as fallback.")
                paths = self.create_default_paths()
            
            return paths

    def create_default_paths(self):
        """ Create default paths when parameter loading fails """
        paths = {}

        # Square path with time
        square_path_time = []
        for i, (x, y, z, w, t) in enumerate([
            (0.0, 0.0, 0.0, 1.0, 0.0), # Starting point
            (2.0, 0.0, -0.7071, 0.7071, 10.0) # First corner
            (2.0, -2.0, -1.0, 0.0, 20.0), # Second corner
            (0.0, -2.0, 0.7071, 0.7071, 30.0), # Third corner
            (0.0, 0.0, 0.0, 1.0, 40.0) # Back to start
        ]):
            point = PathPoint()
            point.pose.position.x = x
            point.pose.position.y = y
            point.pose.orientation.z = z
            point.pose.orientation.w = w
            point.time = t
            square_path_time.append(point)
        paths['square_path_time'] = square_path_time

        # Add other default paths if desired

        return paths

    def publish_path_point(self):
        """ Publish the current path point """
        if not self.current_path or self.current_point_index >= self.total_points:
            self.logger().info("Path completed.")
            self.timer.cancel()
            return
        
        # Get current point
        path_point = self.current_path[self.current_point_index]

        # Publish point
        self.path_point_pub.publish(path_point)

        # Log info
        self.get_logger().info(f"Published point {self.current_point_index+1}/{self.total_points}: "
                              f"pos=({path_point.pose.position.x:.2f}, {path_point.pose.position.y:.2f}), "
                              f"vel=({path_point.velocity.linear.x:.2f}, {path_point.velocity.angular.z:.2f}), "
                              f"time={path_point.time:.2f}")
        
        # Move to next point
        self.current_point_index += 1

        # Check if we reached the end
        if self.current_point_index >= self.total_points:
            self.get_logger().info("Path completed. Stopping publisher.")
            self.timer_cancel()

# Main
def main(args=None):
    rclpy.init(args=args)
    
    # Create the node
    node = PathGeneratorNode()
    
    try:
        rclpy.spin(node)  # This will run the timer callback
    except KeyboardInterrupt:
        node.get_logger().info("Execution interrupted by user")
    finally:
        if rclpy.ok():
            rclpy.shutdown()
        node.destroy_node()

# Execute Node
if __name__ == '__main__':
    main()